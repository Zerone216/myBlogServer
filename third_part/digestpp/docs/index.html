<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>digestpp: digestpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">digestpp
   &#160;<span id="projectnumber">0.01</span>
   </div>
   <div id="projectbrief">Experimental&nbsp;C++11&nbsp;header-only&nbsp;message&nbsp;digest&nbsp;library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">digestpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Experimental C++11 header-only message digest library.</p>
<p>Derived from cppcrypto in an attempt to devise a more modern yet flexible and universal C++ API for cryptographic hash functions.</p>
<p>Tested with g++ 6.4.0, clang 4.0.1 and Visual C++ 2017.</p>
<h2>Examples</h2>
<p>Calculate BLAKE2b digest from a double quoted string and output it in hex format: </p><div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#aba880b81cd06ac625a680797a9c34f6c">blake2b</a>().absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).hexdigest();</div></div><!-- fragment --><p> Calculate BLAKE2b-256 digest from an std::string and output it in hex format: </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> str = <span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</div><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#aba880b81cd06ac625a680797a9c34f6c">blake2b</a>(256).absorb(str).hexdigest();</div></div><!-- fragment --><p> Calculate SHA-512 digest of a vector&lt;unsigned char&gt; and output it in hex format: </p><div class="fragment"><div class="line">vector&lt;unsigned char&gt; v;</div><div class="line"><span class="comment">// ...fill the vector</span></div><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#affd7a1c48ea3fbb97adc51154e534e37">sha512</a>().absorb(v.begin(), v.end()).hexdigest();</div></div><!-- fragment --><p> Calculate SHA-512/256 digest of a C array and output it in hex format: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c[32];</div><div class="line"><span class="comment">// ...fill the array</span></div><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#affd7a1c48ea3fbb97adc51154e534e37">sha512</a>(256).absorb(c, <span class="keyword">sizeof</span>(c)).hexdigest();</div></div><!-- fragment --><p> Calculate SHA-256 digest of a file and output it in hex format: </p><div class="fragment"><div class="line">ifstream file(<span class="stringliteral">&quot;filename&quot;</span>, ios_base::in|ios_base::binary);</div><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#a22fdc9182b2f609a11e0eb906a374f02">sha256</a>().absorb(file).hexdigest();</div></div><!-- fragment --><p> Generate SHA3-224 digest using multiple calls to absorb(): </p><div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a>(224).absorb(<span class="stringliteral">&quot;The quick brown fox &quot;</span>).absorb(<span class="stringliteral">&quot;jumps over the lazy dog&quot;</span>).hexdigest();</div></div><!-- fragment --><p> Output binary digest to a vector&lt;unsigned char&gt;: </p><div class="fragment"><div class="line">vector&lt;unsigned char&gt; v;</div><div class="line"><a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a>(256).absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).digest(back_inserter(v));</div></div><!-- fragment --><p> Output binary digest to a raw C array: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[32];</div><div class="line"><a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a>(256).absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).digest(buf, <span class="keyword">sizeof</span>(buf));</div></div><!-- fragment --><p> Output binary digest to a stream: </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> str = <span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</div><div class="line"><span class="keywordtype">string</span> output;</div><div class="line">ostringstream os(output);</div><div class="line"><a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a>(256).absorb(str).digest(ostream_iterator&lt;char&gt;(os, <span class="stringliteral">&quot;&quot;</span>));</div></div><!-- fragment --><p> Generate long output using SHAKE-256 extendable output function using multiple calls to squeeze(): </p><div class="fragment"><div class="line">vector&lt;unsigned char&gt; v;</div><div class="line"><a class="code" href="namespacedigestpp.html#a534e07d1698662e11be399a6a735b278">shake256</a> xof;</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#aa3c03c169eba04090910d0efb5918d55">absorb</a>(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>);</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#a38089a9a83aeaf01303e55843afb2765">squeeze</a>(1000, back_inserter(v));</div><div class="line">xof.squeeze(1000, back_inserter(v));</div><div class="line">xof.squeeze(1000, back_inserter(v));</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Squeezed &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> Generate 64-byte digest using customizable cSHAKE-256 algorithm and print it in hex format: </p><div class="fragment"><div class="line"><a class="code" href="namespacedigestpp.html#a6df32a29ed44d23d513a920147bf7eb1">cshake256</a> xof;</div><div class="line">xof.set_customization(<span class="stringliteral">&quot;Customization&quot;</span>);</div><div class="line">cout &lt;&lt; xof.absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).hexsqueeze(64);</div></div><!-- fragment --><h2>Hasher class</h2>
<p><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> is a main class template implementing the public API for hashing.</p>
<p>It has two template parameters:</p><ul>
<li>HashProvider is a class implementing the algorithm via traditional init/update/final interface. We provide our own implementations of hash functions listed in the next section, but using the traditional interface allows anyone to trivially implement the providers as wrappers over popular libraries, such as OpenSSL, Crypto++, Botan.</li>
<li>Mixin is a class template which can be used to inject additional functions to the public API of the hasher, for example for setting the customization string for cSHAKE, the salt for BLAKE, etc.</li>
</ul>
<p>See <a class="el" href="classdigestpp_1_1hasher.html">hasher</a> reference documentation for the description of all public functions.</p>
<p>Individual hash algorithms are defined by typedefs, e.g. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> hasher&lt;detail::sha3_provider&gt; <a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> hasher&lt;detail::blake_provider, detail::blake_mixin&gt; <a class="code" href="namespacedigestpp.html#ae7dba91d6b8d9c1ea7c194de33b1f98d">blake</a>;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><h2>Supported algorithms</h2>
<h3>Hash functions</h3>
<table class="doxtable">
<tr>
<th>Typedef</th><th>Description</th><th>Supported output sizes</th><th>Optional parameters  </th></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#ae7dba91d6b8d9c1ea7c194de33b1f98d">blake</a></td><td>Original BLAKE algorithm</td><td>224, 256, 384, 512</td><td>salt </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#aba880b81cd06ac625a680797a9c34f6c">blake2b</a></td><td>BLAKE2b</td><td>8-512</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#aef9e48cee90947e400f975c9ca126aee">blake2s</a></td><td>BLAKE2s</td><td>8-256</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a47975780ffe7d66a274fafb292cbec29">blake2xb</a></td><td>BLAKE2xb</td><td>arbitrary</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#aef4af42ce803e4dd8adc0d3fa8c44dd6">blake2xs</a></td><td>BLAKE2xs</td><td>arbitrary</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a6ad6dd5d19a4e2ba87352e790b9676d2">groestl</a></td><td>Grøstl</td><td>8-512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a392d10c5f15452e692bae608869910ae">jh</a></td><td>JH</td><td>8-512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a90a899ac8acc680665430608f9410c85">kmac128</a></td><td>KMAC128</td><td>arbitrary</td><td>key, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a6f9055e092dd623dc74cf4b0588cb437">kmac256</a></td><td>KMAC256</td><td>arbitrary</td><td>key, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a2f44f2ba13aeb17e2b3e72cb1966ec98">kupyna</a></td><td>Kupyna</td><td>256, 512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a450b5606fcc57a8f9abe786042f94473">md5</a></td><td>MD5</td><td>128</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a891a3fc5d8acf9c887b71065e8d905c1">sha1</a></td><td>SHA-1</td><td>160</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a2eb43b42bfeb66e2dfc423178e39986c">sha224</a></td><td>SHA-224</td><td>224</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a22fdc9182b2f609a11e0eb906a374f02">sha256</a></td><td>SHA-256</td><td>256</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a32f89f2b267ee05fd0d09c862316be5b">sha384</a></td><td>SHA-384</td><td>384</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#affd7a1c48ea3fbb97adc51154e534e37">sha512</a></td><td>SHA-512</td><td>8-512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">sha3</a></td><td>SHA-3</td><td>224, 256, 384, 512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a42dff17296f6568f6209207c9830ced9">skein256</a></td><td>Skein256</td><td>arbitrary</td><td>personalization, key, nonce </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#aaf339a6ac310467790dc8c98a72c4e55">skein512</a></td><td>Skein512</td><td>arbitrary</td><td>personalization, key, nonce </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#aedf53c47c34a42a233357ac50e997d61">skein1024</a></td><td>Skein1024</td><td>arbitrary</td><td>personalization, key, nonce </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a4d97c2838bc84e2bbb0741db58220ad7">sm3</a></td><td>SM3</td><td>256</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a295bebb95a4b1f7ebc8919ce883ce177">streebog</a></td><td>Streebog</td><td>256, 512</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a9b36dbe93f2f5dd08638f108d94f7b14">whirlpool</a></td><td>Whirlpool</td><td>512</td><td>- </td></tr>
</table>
<h3>Extendable output functions</h3>
<table class="doxtable">
<tr>
<th>Typedef</th><th>Description</th><th>Optional parameters  </th></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a7e88d6565dc956c49573f71cba23bddc">blake2xb_xof</a></td><td>BLAKE2xb in XOF mode</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#ab95d8383d5ea7b1c167f8c735a83fe6a">blake2xs_xof</a></td><td>BLAKE2xs in XOF mode</td><td>salt, personalization, key </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a1b65fae1ddea734203f1450f1ee84bc5">k12</a></td><td>KangarooTwelve</td><td>customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#ab25af0ef9a4c4658beca88fbf821a668">m14</a></td><td>MarsupilamiFourteen</td><td>customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a17198d967ff887fb804aecc0a56153d3">shake128</a></td><td>SHAKE-128</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a534e07d1698662e11be399a6a735b278">shake256</a></td><td>SHAKE-256</td><td>- </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a45d4799abd5095ba4caba998afe1472b">cshake128</a></td><td>cSHAKE-128</td><td>function name, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a6df32a29ed44d23d513a920147bf7eb1">cshake256</a></td><td>cSHAKE-256</td><td>function name, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a89668569302df7e0dd03b7174732205b">kmac128_xof</a></td><td>KMAC128 in XOF mode</td><td>key, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#a370a5d0b21206abe72483afdd00d9991">kmac256_xof</a></td><td>KMAC256 in XOF mode</td><td>key, customization </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#afd1645bdfcb0c09731547c93e4484037">skein256_xof</a></td><td>Skein256 in XOF mode</td><td>personalization, key, nonce </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#af5368ab0cf2c45b381ee63776d332915">skein512_xof</a></td><td>Skein512 in XOF mode</td><td>personalization, key, nonce </td></tr>
<tr>
<td><a class="el" href="namespacedigestpp.html#af11db7a8a4a8458bdfbeae3cccf9f389">skein1024_xof</a></td><td>Skein1024 in XOF mode</td><td>personalization, key, nonce </td></tr>
</table>
<h2>Design rationale in questions and answers</h2>
<p>Q: What is the difference between a hash function with variable output size and an extendable output function (XOF)?</p>
<p>A: Hash functions require the digest size to be known at the moment of initialization and normally produce unrelated outputs for different digest sizes. For example, <code>blake2b(256)</code> and <code>blake2b(512)</code> produce completely different digests. XOFs are functions that do not need to know the output size in advance and can produce outputs of unrestricted size. Bytes generated by XOFs depend only on the input data, but not on the digest size. It is generally recommended to use hash functions instead of XOFs when the output size is known in advance.</p>
<p>Q: What is the difference between <code>digest()</code> and <code>squeeze()</code>?</p>
<p>A. <code>digest()</code> is used with hash functions; it retrieves a digest of a certain length (defined by the algorithm or specified in the constructor). Calling <code>digest()</code> or <code>hexdigest()</code> does not change the internal state, so that these functions can be called more than once and will produce the same output. <code>squeeze()</code> is used with XOF functions; it can be called multiple times to squeeze an arbitrary number of output bytes. After each invocation of <code>squeeze()</code> the internal state changes so that the next call to <code>squeeze()</code> will generate different (additional) output bytes.</p>
<p>Q: For hash functions with variable output size, why the output size is not a template parameter, e.g. <code>sha3&lt;256&gt;</code>?</p>
<p>A: While it may seem cool to make the output size a template parameter, in some usage scenarios the required digest size is not known at compile time. One simple example is Argon2 password hashing algorithm, which requires us to hash its state using BLAKE2b with dynamically calculated digest size. We can't just use the largest digest size and truncate the result, because most hash functions (unlike XOFs) produce completely different digests depending on the requested output size. Using a template parameter for the digest size would encumber implementation of such algorithms. Additionally, some hash functions support arbitrary output sizes which are not limited by the security level (examples of such functions are Skein, BLAKE2x, ParallelHash). Some functions are specifically designed to be usable both in hashing and in XOF modes, where the required output size is not known in advance even at runtime. Taking all this factors in consideration, specifying the output size at compile time does not seem like a good design.</p>
<p>Q: Why <code>hasher</code> does not support hashing non-byte types?</p>
<p>A: Cryptographic hash functions are always defined for a sequence of bytes. We support only those data types that can be unambiguosly converted to bytes (sequences of <code>char</code>, <code>signed char</code>, or <code>unsigned char</code>). Other data types should be converted to a sequence of bytes in non-ambiguous way before they can be hashed (eg wide strings could be encoded using UTF-8 or another encoding), which is beyond the scope of the library.</p>
<p>Q: Since the output size has to be provided to the constructor, why there are separate typedefs for <code>sha256</code> and <code>sha512</code> instead of one hasher with output size parameter: <code>sha2(256)</code> / <code>sha2(512)</code>?</p>
<p>A: SHA-2 family of hash functions is special because SHA-512 can produce output of any size up to 512 bits (SHA-512/t), e.g. <code>sha512(256)</code> will calculate SHA-512/256. The resulting hash is different from SHA-256, but has the same length. Thus SHA-512 is an independent hash function supporting variable output sizes. On the other hand, the 32-bit version of SHA-2 is only defined for 224-bit and 256-bit outputs, and they are widely known as SHA-224 and SHA-256. We decided to use different typedefs for SHA-224 and SHA-256 because requiring users to use <code>sha256(224)</code> for getting SHA-224 digests would be confusing. Internally all SHA-2 functions are implemented using one template class.</p>
<p>Q: Why there are separate typedefs for <code>skein256</code>, <code>skein512</code> and <code>skein1024</code> instead of one hasher with output size parameter: <code>skein(256)</code> / <code>skein(512)</code> / <code>skein(1024)</code>?</p>
<p>A: Skein256, Skein512 and Skein1024 are different algorithms. Each of them can produce digests of any size. The outputs are unrelated, e.g. <code>skein256(256)</code> != <code>skein512(256)</code> != <code>skein1024(256)</code>. Internally all Skein variants are implemented using one template class.</p>
<p>Q: Why there are so many typedefs for BLAKE2 hash function?</p>
<p>A: BLAKE2 has many variants that produce incompatible digests for the same output sizes. We support different variants via different typedef. For the 512-bit version, <code>blake2b</code> is the oldest algorithm which can produce digests of any size up to 512 bits. <code>blake2xb</code> can be used to produce larger digests but requires the output size to be known in advance; it can't be merged with <code>blake2b</code> because their output are different for the same digest sizes. <code>blake2xb_xof</code> can be used in XOF mode when the output size is not known in advance. Then there is a 256-bit version <code>blake2s</code> which supports all this variants as well. Internally all BLAKE2 variants are implemented using one template class.</p>
<h2>Known limitations</h2>
<ul>
<li>Included providers are written in standard C++ and may be slower than SIMD optimized implementations.</li>
<li>Only complete bytes are supported for input and output.</li>
<li>Big endian systems are not supported.</li>
<li>No attempts were made to make implementation of every algorithm constant time. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
