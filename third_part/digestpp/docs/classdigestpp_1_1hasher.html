<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>digestpp: digestpp::hasher&lt; HashProvider, Mixin &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">digestpp
   &#160;<span id="projectnumber">0.01</span>
   </div>
   <div id="projectbrief">Experimental&nbsp;C++11&nbsp;header-only&nbsp;message&nbsp;digest&nbsp;library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedigestpp.html">digestpp</a></li><li class="navelem"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdigestpp_1_1hasher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">digestpp::hasher&lt; HashProvider, Mixin &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main class template implementing the public API for hashing.  
 <a href="classdigestpp_1_1hasher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hasher_8hpp_source.html">hasher.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for digestpp::hasher&lt; HashProvider, Mixin &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdigestpp_1_1hasher.png" usemap="#digestpp::hasher_3C_20HashProvider_2C_20Mixin_20_3E_map" alt=""/>
  <map id="digestpp::hasher_3C_20HashProvider_2C_20Mixin_20_3E_map" name="digestpp::hasher_3C_20HashProvider_2C_20Mixin_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a05520419d6d96f67e2e33f73d9eb5f84"><td class="memTemplParams" colspan="2">template&lt;typename H  = HashProvider, typename std::enable_if&lt; std::is_default_constructible&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a05520419d6d96f67e2e33f73d9eb5f84"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a05520419d6d96f67e2e33f73d9eb5f84">hasher</a> ()</td></tr>
<tr class="memdesc:a05520419d6d96f67e2e33f73d9eb5f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a05520419d6d96f67e2e33f73d9eb5f84">More...</a><br /></td></tr>
<tr class="separator:a05520419d6d96f67e2e33f73d9eb5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50f839cb4e7e327acaae525cb20e08f"><td class="memTemplParams" colspan="2">template&lt;typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab50f839cb4e7e327acaae525cb20e08f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#ab50f839cb4e7e327acaae525cb20e08f">hasher</a> (size_t hashsize)</td></tr>
<tr class="memdesc:ab50f839cb4e7e327acaae525cb20e08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with hash size parameter.  <a href="#ab50f839cb4e7e327acaae525cb20e08f">More...</a><br /></td></tr>
<tr class="separator:ab50f839cb4e7e327acaae525cb20e08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c03c169eba04090910d0efb5918d55"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3c03c169eba04090910d0efb5918d55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#aa3c03c169eba04090910d0efb5918d55">absorb</a> (const T *data, size_t len)</td></tr>
<tr class="memdesc:aa3c03c169eba04090910d0efb5918d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorbs bytes from a C-style pointer to character buffer.  <a href="#aa3c03c169eba04090910d0efb5918d55">More...</a><br /></td></tr>
<tr class="separator:aa3c03c169eba04090910d0efb5918d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87176a2df40b7f7c8b800ad137607a44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, std::string::value_type &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a87176a2df40b7f7c8b800ad137607a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a87176a2df40b7f7c8b800ad137607a44">absorb</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:a87176a2df40b7f7c8b800ad137607a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorbs bytes from std::basic_string.  <a href="#a87176a2df40b7f7c8b800ad137607a44">More...</a><br /></td></tr>
<tr class="separator:a87176a2df40b7f7c8b800ad137607a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce48d3734b5c2ec346c40751f34b981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#afce48d3734b5c2ec346c40751f34b981">absorb</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:afce48d3734b5c2ec346c40751f34b981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorbs bytes from std::string.  <a href="#afce48d3734b5c2ec346c40751f34b981">More...</a><br /></td></tr>
<tr class="separator:afce48d3734b5c2ec346c40751f34b981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58d5362c2c9e2b1e10c8f597d991a1e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae58d5362c2c9e2b1e10c8f597d991a1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#ae58d5362c2c9e2b1e10c8f597d991a1e">absorb</a> (std::basic_istream&lt; T &gt; &amp;istr)</td></tr>
<tr class="memdesc:ae58d5362c2c9e2b1e10c8f597d991a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorbs bytes from std::istream.  <a href="#ae58d5362c2c9e2b1e10c8f597d991a1e">More...</a><br /></td></tr>
<tr class="separator:ae58d5362c2c9e2b1e10c8f597d991a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3401351a03516a8f604b070c3d7f821"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:aa3401351a03516a8f604b070c3d7f821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#aa3401351a03516a8f604b070c3d7f821">absorb</a> (IT begin, IT end)</td></tr>
<tr class="memdesc:aa3401351a03516a8f604b070c3d7f821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorbs bytes from an iterator sequence.  <a href="#aa3401351a03516a8f604b070c3d7f821">More...</a><br /></td></tr>
<tr class="separator:aa3401351a03516a8f604b070c3d7f821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38089a9a83aeaf01303e55843afb2765"><td class="memTemplParams" colspan="2">template&lt;typename T , typename H  = HashProvider, typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a38089a9a83aeaf01303e55843afb2765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a38089a9a83aeaf01303e55843afb2765">squeeze</a> (T *buf, size_t len)</td></tr>
<tr class="memdesc:a38089a9a83aeaf01303e55843afb2765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squeeze bytes into user-provided preallocated buffer.  <a href="#a38089a9a83aeaf01303e55843afb2765">More...</a><br /></td></tr>
<tr class="separator:a38089a9a83aeaf01303e55843afb2765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0dcab9509fb5ff2809af16f8e29a75"><td class="memTemplParams" colspan="2">template&lt;typename OI , typename H  = HashProvider, typename std::enable_if&lt; detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f0dcab9509fb5ff2809af16f8e29a75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a9f0dcab9509fb5ff2809af16f8e29a75">squeeze</a> (size_t len, OI it)</td></tr>
<tr class="memdesc:a9f0dcab9509fb5ff2809af16f8e29a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squeeze bytes into an output iterator.  <a href="#a9f0dcab9509fb5ff2809af16f8e29a75">More...</a><br /></td></tr>
<tr class="separator:a9f0dcab9509fb5ff2809af16f8e29a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c54688aba55d04bc0f015b67dbf112"><td class="memTemplParams" colspan="2">template&lt;typename H  = HashProvider, typename std::enable_if&lt; detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a96c54688aba55d04bc0f015b67dbf112"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a96c54688aba55d04bc0f015b67dbf112">hexsqueeze</a> (size_t len)</td></tr>
<tr class="memdesc:a96c54688aba55d04bc0f015b67dbf112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squeeze bytes and return them as a hex string.  <a href="#a96c54688aba55d04bc0f015b67dbf112">More...</a><br /></td></tr>
<tr class="separator:a96c54688aba55d04bc0f015b67dbf112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c07aa70580501eb59149956b5ee33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename H  = HashProvider, typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c1c07aa70580501eb59149956b5ee33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a3c1c07aa70580501eb59149956b5ee33">digest</a> (T *buf, size_t len) const</td></tr>
<tr class="memdesc:a3c1c07aa70580501eb59149956b5ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output binary digest into user-provided preallocated buffer.  <a href="#a3c1c07aa70580501eb59149956b5ee33">More...</a><br /></td></tr>
<tr class="separator:a3c1c07aa70580501eb59149956b5ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933121da1174c66deb2961ccb7136433"><td class="memTemplParams" colspan="2">template&lt;typename OI , typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a933121da1174c66deb2961ccb7136433"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a933121da1174c66deb2961ccb7136433">digest</a> (OI it) const</td></tr>
<tr class="memdesc:a933121da1174c66deb2961ccb7136433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write binary digest into an output iterator.  <a href="#a933121da1174c66deb2961ccb7136433">More...</a><br /></td></tr>
<tr class="separator:a933121da1174c66deb2961ccb7136433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc08bdd98e7580e14f8f9b971708c54"><td class="memTemplParams" colspan="2">template&lt;typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1bc08bdd98e7580e14f8f9b971708c54"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a1bc08bdd98e7580e14f8f9b971708c54">hexdigest</a> () const</td></tr>
<tr class="memdesc:a1bc08bdd98e7580e14f8f9b971708c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hex digest of absorbed data.  <a href="#a1bc08bdd98e7580e14f8f9b971708c54">More...</a><br /></td></tr>
<tr class="separator:a1bc08bdd98e7580e14f8f9b971708c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326f76f7f383d4ab137f2094407b1013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> (bool resetParameters=false)</td></tr>
<tr class="memdesc:a326f76f7f383d4ab137f2094407b1013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the hasher state to start new digest computation.  <a href="#a326f76f7f383d4ab137f2094407b1013">More...</a><br /></td></tr>
<tr class="separator:a326f76f7f383d4ab137f2094407b1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class HashProvider, template&lt; class &gt; class Mixin = mixin::null_mixin&gt;<br />
class digestpp::hasher&lt; HashProvider, Mixin &gt;</h3>

<p>Main class template implementing the public API for hashing. </p>
<p>Individual hash functions are defined by typedefs. See <a class="el" href="namespacedigestpp.html">digestpp</a> namespace description for description of supported hash functions with usage examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HashProvider</td><td>A class implementing the algorithm via traditional init/update/final interface. </td></tr>
    <tr><td class="paramname">Mixin</td><td>A class template which can be used to inject additional functions to the public API of the hasher.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedigestpp.html" title="digestpp namespace ">digestpp</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a05520419d6d96f67e2e33f73d9eb5f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05520419d6d96f67e2e33f73d9eb5f84">&#9670;&nbsp;</a></span>hasher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename H  = HashProvider, typename std::enable_if&lt; std::is_default_constructible&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::<a class="el" href="classdigestpp_1_1hasher.html">hasher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section user"><dt>Available if</dt><dd><ul>
<li>HashProvider is a hash function with fixed output size, OR</li>
<li>HashProvider is a hash function with sensible default output size, OR</li>
<li>HashProvider is an extendable output function (XOF) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab50f839cb4e7e327acaae525cb20e08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50f839cb4e7e327acaae525cb20e08f">&#9670;&nbsp;</a></span>hasher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::<a class="el" href="classdigestpp_1_1hasher.html">hasher</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hashsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with hash size parameter. </p>
<p>Supported output sizes for each algorithm are listed in the description of corresponding typedef.</p>
<dl class="section user"><dt>Available if</dt><dd><ul>
<li>HashProvider supports multiple output sizes, AND</li>
<li>HashProvider is not an extendable output function (XOF)</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashsize</td><td>Desired output digest size (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the requested output size is not supported by the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3c03c169eba04090910d0efb5918d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c03c169eba04090910d0efb5918d55">&#9670;&nbsp;</a></span>absorb() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a>&amp; <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::absorb </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absorbs bytes from a C-style pointer to character buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data to absorb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of data to absorb (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Calculate SHA-512/256 digest of a C array and output it in hex format</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c[32];</div><div class="line">std::iota(c, c + <span class="keyword">sizeof</span>(c), 0);</div><div class="line">cout &lt;&lt; <a class="code" href="namespacedigestpp.html#affd7a1c48ea3fbb97adc51154e534e37">digestpp::sha512</a>(256).absorb(c, <span class="keyword">sizeof</span>(c)).hexdigest() &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a87176a2df40b7f7c8b800ad137607a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87176a2df40b7f7c8b800ad137607a44">&#9670;&nbsp;</a></span>absorb() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, std::string::value_type &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a>&amp; <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::absorb </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absorbs bytes from std::basic_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to absorb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>

</div>
</div>
<a id="afce48d3734b5c2ec346c40751f34b981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce48d3734b5c2ec346c40751f34b981">&#9670;&nbsp;</a></span>absorb() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a>&amp; <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::absorb </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absorbs bytes from std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to absorb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Calculate BLAKE2b-256 digest from an std::string and output it in hex format</span></div><div class="line">std::string str = <span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</div><div class="line">std::cout &lt;&lt; <a class="code" href="namespacedigestpp.html#aba880b81cd06ac625a680797a9c34f6c">digestpp::blake2b</a>(256).absorb(str).hexdigest() &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae58d5362c2c9e2b1e10c8f597d991a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58d5362c2c9e2b1e10c8f597d991a1e">&#9670;&nbsp;</a></span>absorb() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a>&amp; <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::absorb </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>istr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absorbs bytes from std::istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">istr</td><td>Stream to absorb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Calculate SHA-256 digest of a file and output it in hex format</span></div><div class="line">std::ifstream file(<span class="stringliteral">&quot;filename&quot;</span>, std::ios_base::in|std::ios_base::binary);</div><div class="line">std::cout &lt;&lt; <a class="code" href="namespacedigestpp.html#a22fdc9182b2f609a11e0eb906a374f02">digestpp::sha256</a>().absorb(file).hexdigest() &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa3401351a03516a8f604b070c3d7f821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3401351a03516a8f604b070c3d7f821">&#9670;&nbsp;</a></span>absorb() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename IT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigestpp_1_1hasher.html">hasher</a>&amp; <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::absorb </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absorbs bytes from an iterator sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>Begin iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>End iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Calculate SHA-512 digest of a vector and output it in hex format</span></div><div class="line">std::vector&lt;unsigned char&gt; v(100);</div><div class="line">std::iota(v.begin(), v.end(), 0);</div><div class="line">std::cout &lt;&lt; <a class="code" href="namespacedigestpp.html#affd7a1c48ea3fbb97adc51154e534e37">digestpp::sha512</a>().absorb(v.begin(), v.end()).<a class="code" href="classdigestpp_1_1hasher.html#a1bc08bdd98e7580e14f8f9b971708c54">hexdigest</a>() &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3c1c07aa70580501eb59149956b5ee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c07aa70580501eb59149956b5ee33">&#9670;&nbsp;</a></span>digest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename H  = HashProvider, typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::digest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output binary digest into user-provided preallocated buffer. </p>
<p>This function does not change the state of the hasher and can be called multiple times, producing the same result. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is a hash function (not XOF)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to squeeze data to; must be of byte type (char, unsigned char or signed char) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the buffer size is not enough to fit the calculated digest (fixed by the algorithm or specified in the hasher constructor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Output binary digest to a raw C array</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[32];</div><div class="line"><a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">digestpp::sha3</a>(256).absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).digest(buf, <span class="keyword">sizeof</span>(buf));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a933121da1174c66deb2961ccb7136433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933121da1174c66deb2961ccb7136433">&#9670;&nbsp;</a></span>digest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename OI , typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::digest </td>
          <td>(</td>
          <td class="paramtype">OI&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write binary digest into an output iterator. </p>
<p>This function does not change the state of the hasher and can be called multiple times, producing the same result. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is a hash function (not XOF)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">it</td><td>Output iterator to a byte container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Output binary SHA3-256 digest to a vector</span></div><div class="line">vector&lt;unsigned char&gt; v;</div><div class="line"><a class="code" href="namespacedigestpp.html#a4ac862e124d2502301eb501a6466b8dc">digestpp::sha3</a>(256).absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).digest(back_inserter(v));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1bc08bdd98e7580e14f8f9b971708c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc08bdd98e7580e14f8f9b971708c54">&#9670;&nbsp;</a></span>hexdigest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename H  = HashProvider, typename std::enable_if&lt;!detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::hexdigest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return hex digest of absorbed data. </p>
<p>This function does not change the state of the hasher and can be called multiple times, producing the same result. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is a hash function (not XOF)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated digest as a hexademical string </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Calculate BLAKE2b digest from a double quoted string and output it in hex format</span></div><div class="line">std::cout &lt;&lt; <a class="code" href="namespacedigestpp.html#aba880b81cd06ac625a680797a9c34f6c">digestpp::blake2b</a>().absorb(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).hexdigest() &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a96c54688aba55d04bc0f015b67dbf112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c54688aba55d04bc0f015b67dbf112">&#9670;&nbsp;</a></span>hexsqueeze()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename H  = HashProvider, typename std::enable_if&lt; detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::hexsqueeze </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squeeze bytes and return them as a hex string. </p>
<p>After each invocation of this function the internal state of the hasher changes so that the next call will generate different (additional) output bytes. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is an extendable output function (XOF)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of data to squeeze (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated digest as a hexademical string </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Generate 64-byte digest using customizable cSHAKE-256 algorithm and print it in hex format</span></div><div class="line"><a class="code" href="classdigestpp_1_1hasher.html">digestpp::cshake256</a> xof;</div><div class="line">xof.set_customization(<span class="stringliteral">&quot;My Customization&quot;</span>);</div><div class="line">std::cout &lt;&lt; xof.<a class="code" href="classdigestpp_1_1hasher.html#aa3c03c169eba04090910d0efb5918d55">absorb</a>(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>).<a class="code" href="classdigestpp_1_1hasher.html#a96c54688aba55d04bc0f015b67dbf112">hexsqueeze</a>(64) &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a326f76f7f383d4ab137f2094407b1013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326f76f7f383d4ab137f2094407b1013">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParameters</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the hasher state to start new digest computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resetParameters</td><td>if true, also clear optional parameters (personalization, salt, etc) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38089a9a83aeaf01303e55843afb2765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38089a9a83aeaf01303e55843afb2765">&#9670;&nbsp;</a></span>squeeze() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename H  = HashProvider, typename std::enable_if&lt; detail::is_byte&lt; T &gt;::value &amp;&amp;detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::squeeze </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squeeze bytes into user-provided preallocated buffer. </p>
<p>After each invocation of this function the internal state of the hasher changes so that the next call will generate different (additional) output bytes. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is an extendable output function (XOF)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to squeeze data to; must be of byte type (char, unsigned char or signed char) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of data to squeeze (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0dcab9509fb5ff2809af16f8e29a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0dcab9509fb5ff2809af16f8e29a75">&#9670;&nbsp;</a></span>squeeze() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashProvider , template&lt; class &gt; class Mixin = mixin::null_mixin&gt; </div>
<div class="memtemplate">
template&lt;typename OI , typename H  = HashProvider, typename std::enable_if&lt; detail::is_xof&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigestpp_1_1hasher.html">digestpp::hasher</a>&lt; HashProvider, Mixin &gt;::squeeze </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OI&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squeeze bytes into an output iterator. </p>
<p>After each invocation of this function the internal state of the hasher changes so that the next call will generate different (additional) output bytes. To reset the state and start new digest calculation, use <a class="el" href="classdigestpp_1_1hasher.html#a326f76f7f383d4ab137f2094407b1013">reset</a> function.</p>
<dl class="section user"><dt>Available if</dt><dd>HashProvider is an extendable output function (XOF)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of data to squeeze (in bytes) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">it</td><td>output iterator to a byte container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"> <span class="comment">// Generate long output using SHAKE-256 extendable output function using multiple calls to squeeze()</span></div><div class="line">std::vector&lt;unsigned char&gt; v;</div><div class="line"><a class="code" href="classdigestpp_1_1hasher.html">digestpp::shake256</a> xof;</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#aa3c03c169eba04090910d0efb5918d55">absorb</a>(<span class="stringliteral">&quot;The quick brown fox jumps over the lazy dog&quot;</span>);</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#a38089a9a83aeaf01303e55843afb2765">squeeze</a>(1000, back_inserter(v));</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#a38089a9a83aeaf01303e55843afb2765">squeeze</a>(1000, back_inserter(v));</div><div class="line">xof.<a class="code" href="classdigestpp_1_1hasher.html#a38089a9a83aeaf01303e55843afb2765">squeeze</a>(1000, back_inserter(v));</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Squeezed &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="hasher_8hpp_source.html">hasher.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
